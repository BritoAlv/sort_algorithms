\documentclass[14pt]{extarticle}
\usepackage[left=2cm , right = 2cm, top=2cm]{geometry}
\usepackage{helvet}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[spanish]{babel}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}
\usepackage{hyperref}
\renewcommand{\sfdefault}{lmss}  % este activa la letra lmss
\renewcommand{\familydefault}{\sfdefault} % este activa la letra lmss
\sffamily % este activa la letra lmss
\begin{document}

@BritoAlv


\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black, title = Insertion Sort]
Dado un array de tamaño $N$ de \textbf{int}, ordenarlo de menor a mayor    
\end{tcolorbox}


\begin{enumerate}
    \item La idea es recorrer el array entero desde la posición $1$ hasta la posición $N-1$ (última), \textbf{garantizando que al acabar la iteración $i$, el array desde la posición $0$ hasta la $i$ esté ordenado.} Notar que esto implica que al \textbf{comenzar la iteración en la posición $i$ el array está ordenado desde la posición $0$ hasta la posición $i-1$.}
    \item Por lo que el algoritmo consiste en dos partes, un \textbf{for} para recorrer el array desde la posición $1$ hasta la $N-1$, y en cada iteración del \textbf{for} un algoritmo que ubique al número $i$ en la posición correspondiente entre $0$ a $i-1$, de forma que el arreglo desde $0$ a $i$ quede ordenado.
    \item El primer \textbf{for} recorre $N-1$ elementos $\to O(n)$, para cada uno de esos elementos aplicamos otro algoritmo, este puede ser:
    \item \textbf{Swaps}, ir cambiando hasta llegar a la posición correcta, sería así ejemplo: $2,5,6,3 \, \to \, 2,5,3,6 \, \to \, 2,3,5,6 \,$. Este método de \textbf{Swaps} realiza dos operaciones: \textbf{Comparar e intercambiar, compara si no es esta la posición, intercambia y vuelve a comparar, hasta llegar a la posición, la cantidad de comparaciones es a lo más una unidad mayor que la cantidad de intercambios, usando este método de swap.} El costo por defecto de la operación de comparar e intercambiar es constante, pero y si no lo fuera, una manera de reducir el número de comparaciones es \text{usar binary search} para hallar la posición donde va el elemento $i$ y realizar los swaps correspondientes. 
    \item \textbf{Binary Search}, ir dividiendo el arreglo en mitades, hasta encontrar la posición donde va el número. \textbf{*Teniendo esta posición hacemos los swaps, o shift the array one position to the right*}.
         
\end{enumerate}
\begin{center}
    \textbf{Observaciones}
\end{center}

\begin{enumerate}
    \item Para cada $i$ insertion sort, realiza lo siguiente, inserta el número $i$ en un array de tamaño $i$, a través de swaps, independientementde de si se use binary search o no, el tendrá que realizar los swaps para insertar al número $i$, esto se realiza en tiempo lineal, \textbf{la complejidad del siguiente problema es lineal: dado un arreglo de tamaño n+1, insertar el número en la posición n en la posición i}, el peor caso de esto es cuando $i = 0$ que tendría que realizar $n$ swaps, por lo que su complejidad es linear. La utilidad de binary search es para reducir el número de comparaciones, que sería eficiente cuando realizar comparaciones tenga un costo mayor. Por lo que concluyo que la complejidad es cuadrática. $O(n*(n + \log_2{n}))$ que es $O(n^2)$. 
    \item Insertion Sort es ideal para arreglos almost-sorted porque su tiempo de ejecución radica en cuantas veces haya que realizar los \textbf{swap} para cada elemento. \textbf{De esto se saca que en un array ordenado (ideal) su complejidad es $O(n)$ porque no hay que hacer swaps y en uno ordenado pero decrecientemente su complejidad es $O(n^2)$ porque hay que hacer todos los swaps. }
    \item Los algoritmos de sorting, son \textbf{abstracciones} ellos deben funcionar con cualquier estructura que tenga definida que significa que un elemento sea mayor que otro. 
\end{enumerate}


\end{document}

